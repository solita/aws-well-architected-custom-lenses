{
    "schemaVersion": "2021-11-01",
    "name": "Container Build Lens",
    "description": "Best practices and strategies to use when designing container images. This lens was created by Solita (https://www.solita.fi/en/) and maintained in https://github.com/solita/aws-well-architected-custom-lenses/.",
    "pillars": [
        {
            "id": "OPS",
            "name": "Operational excellence",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_OPS_01",
                    "title": "OPS 1. Prepare - How do you manage the lifecycle of your containers and images?",
                    "description": "How do you manage the lifecycle of your containers and images?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Understand the lineage of your container image",
                            "helpfulResource": {
                                "displayText": "Starting with a minimal container image will save space and speed up the starting of your container when it’s deployed into production.\n\nParent images are minimal images that put into place requirements and security controls established by the organization. For example, the parent image can configure an internal package source repository that contains curated and validated library package versions.\n\nUnderstanding the lineage of your container image helps you efficiently develop, run, manage, and maintain your containers. It also helps maintain your security posture. You can find more details in the Security Pillar whitepaper.",
                                "url": "https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/welcome.html"
                            },
                            "improvementPlan": {
                                "displayText": "Start with a minimal container image."
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Have parity between your deployment environments",
                            "helpfulResource": {
                                "displayText": "A major benefit of using containers is to provide the ability for the development team to develop new updates and features using an identical artifact that runs in production. As much as possible, development, testing, QA, and production environments in that it will be eventually deployed should be as similar as possible. All environments should share best practices for everything, with the differences between them being the ability to scale and the data operated upon. Best practices for development environments differ between orchestration tools so make sure you are following recommendations based on your containerized platform of choice."
                            },
                            "improvementPlan": {
                                "displayText": "Strive to make environments as similar as possible"
                            }
                        },
                        {
                            "id": "choice3",
                            "title": "Build the image once and use the same image in all environments",
                            "helpfulResource": {
                                "displayText": "Once the new image has been built with the updates in place for deployment, promote the same image into the next environment, testing, QA, and production, to provide for consistency across all environments. This will reduce the number of changes introduced in each new environment and provide for more consistent behavior."
                            },
                            "improvementPlan": {
                                "displayText": "Build the image once and use the same image in all environments"
                            }
                        },
                        {
                            "id": "choice4",
                            "title": "Use a CI/CD build process",
                            "helpfulResource": {
                                "displayText": "Like with your applications, you should use a CI/CD pipeline to build and test your images through every stage in your development process."
                            },
                            "improvementPlan": {
                                "displayText": "Use a CI/CD build process"
                            }
                        },
                        {
                            "id": "choice5",
                            "title": "Multi-stage builds",
                            "helpfulResource": {
                                "displayText": "Small container images have undeniable performance advantages. The pull from the registry is faster because less data is transferred over the network, and the container startup time is also reduced. This can be achieved by using multi-stage builds. With this mechanism, you can split the build-phase of the image from the final image that will be used to run the application."
                            },
                            "improvementPlan": {
                                "displayText": "Use multi-stage builds"
                            }
                        },
                        {
                            "id": "choice6",
                            "title": "Implement a minimal container image design to achieve your business and security objectives",
                            "helpfulResource": {
                                "displayText": "It is important to build into your container image only what is necessary. Pictures and other static assets should be stored in a data store, for example Amazon Simple Storage Service (Amazon S3) in AWS, and served through a content delivery network (CDN). This will achieve a minimal container image size, which does not only reduce the storage and running host resource requirements, but it also speeds up the instantiation of a new container from an image if the image itself is not cached locally."
                            },
                            "improvementPlan": {
                                "displayText": "Implement a minimal container image design"
                            }
                        },
                        {
                            "id": "choice7",
                            "title": "Using package managers to deploy your containerized applications",
                            "helpfulResource": {
                                "displayText": "When building a containerized application, the deployable unit can be not only the container image, but its per-environment configuration that is deployed alongside with the container image to the target environment. To achieve this, users can use packaging tooling such as Helm and Kustomize for Kubernetes, AWS Copilot for Amazon Elastic Container Service (Amazon ECS), Docker Swarm for Docker, and more."
                            },
                            "improvementPlan": {
                                "displayText": "Use a package manager to deploy your containerized application"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2 && choice3 && choice4 && choice5 && choice6 && choice7",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "choice1 && choice4",
                            "risk": "MEDIUM_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_OPS_02",
                    "title": "OPS 2. Operate - How do you know whether your containerized workload is achieving its business goals?",
                    "description": "An important part of operating any workload is understanding the health of your workload quickly. The sooner an issue can be identified the better. To ensure the success of your running container, you must understand the health of your containerized workload as well as what your customers are experiencing when they interact with your application.",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Implement health checks to determine container state",
                            "helpfulResource": {
                                "displayText": "Health checks are one way to determine the health of your running container. They enable your orchestration tooling to direct connection traffic to the container only when it is ready to accept connections, or stop routing connections to the container if the health checks show that the container is no longer running as expected. In the latter case, the orchestration tooling will tear down the misbehaving container and replace it with a new healthy one.\n\nFor example, with Amazon ECS you can define health checks as part of the task definition, and perform load balancer health checks for your running application.\n\nFor Kubernetes and Amazon Elastic Kubernetes Service (Amazon EKS), you can take advantage of features such as liveness probes to detect deadlock condition, readiness probes to determine if the pod is prepared to receive requests, and startup probes to know when the application running in the container has started. Liveness probes can either be shell commands or HTTP requests of TCP probes."
                            },
                            "improvementPlan": {
                                "displayText": "Implement container health checks"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Have your logs available outside the running container",
                            "helpfulResource": {
                                "displayText": "Ensure that the logs generated by your running containers are collected and accessible externally. This will enable you to use log monitors to gain more insights into the behavior and functionality of your running container. Your application should be writing its logs to STDOUT and STDERR so that a logging agent can ship the logs to your log monitoring system.\n\nAs with other application workloads, you must understand the metrics and messages that you have collected from your workload. Not only must you understand the data emitted by your containers, but you must also have a standardized log format to easily evaluate the data with your logging tools. Logging collector and forwarder tools give you the ability to standardize your log format across multiple containerized services.\n\nTo enable you and your team to pinpoint where issues may be occurring, define your log messages to be consistently structured to enable correlation of logs across multiple microservices in your central logging system.\n\nThis understanding enables you to evolve your workload to respond to external pressures such as increased traffic or issues with external APIs that your workload may use in the course of accomplishing its business goals."
                            },
                            "improvementPlan": {
                                "displayText": "Have your logs available outside the running container"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "choice1 && !choice2 || !choice1 && choice2",
                            "risk": "MEDIUM_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                }
            ]
        },
        {
            "id": "SEC",
            "name": "Security",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_SEC_01",
                    "title": "SEC 1. Identity and access management - How do you ensure that your container images are using least privilege identity?",
                    "description": "How do you ensure that your container images are using least privilege identity?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use least privilege identity in containers",
                            "helpfulResource": {
                                "displayText": "By default, containers provide process isolation. This means that processes running inside of a container are isolated from processes and data that exist in other containers as well as the container host’s operating system. However, it is important to note that the default behavior is to run the container using the root user when running a container. When the processes inside the container are running as the root user, not only do they have full administrative access to containers, they also have the same administrative level access to the container host.\n\nHaving an application running within a container through the root user expands the attack surface of the environment. This could provide bad actors with the ability to escalate privilege to the container host infrastructure if the application is compromised. There are multiple ways to mitigate this risk. The most straightforward method is to define the USER directive in the Dockerfile."
                            },
                            "improvementPlan": {
                                "displayText": "Use the USER directive to limit privileges"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SEC_02",
                    "title": "SEC 2. Identity and access management - How do you control access to your build infrastructure?",
                    "description": "How do you control access to your build infrastructure?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Limit administrator access to build infrastructure (CI pipeline)",
                            "helpfulResource": {
                                "displayText": "Adding continuous security validation in a build pipeline is a major focus for organizations moving to a DevSecOps strategy. This helps ensure that security is built into the application from the beginning of the application’s lifecycle as opposed to performing security testing only at the end of the development process. However, it is important to note that securing an organization’s build pipeline should be considered a high priority as well, as the pipeline typically accesses databases, proprietary code, and secrets or credentials across dev, test, and prod environments.\n\nA compromised build pipeline could provide a bad actor with access to all of the preceding resources in a customer environment. As detailed in the security pillar of the AWS Well-Architected Framework, it is important to follow the best practice of granting the least privileged access to the container build infrastructure. The least privileged best practice should be applied to human identities as well as machine identities. An example might be that a human identity that has access to the container build infrastructure can reach an application’s source code, secrets, and other sensitive data."
                            },
                            "improvementPlan": {
                                "displayText": "Limit administrator access to build infrastructure (CI pipeline)"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SEC_03",
                    "title": "SEC 3. Detective controls - How do you detect and address vulnerabilities within your container image?",
                    "description": "How do you detect and address vulnerabilities within your container image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Ensure that your images are scanned for vulnerabilities",
                            "helpfulResource": {
                                "displayText": "After images are built, it is important to maintain a regular cadence of scanning those images to ensure no new or existing vulnerabilities have surfaced. There are two basic categories to consider when discussing image scanning: static scanning and dynamic scanning. Static scanning is performed before the image is deployed. This is important because it allows organizations to detect vulnerabilities in a container image before a container is deployed into an environment. Many registry offerings provide native static image scanning that can scan container images for common vulnerabilities and exposures (CVEs) without having to integrate and maintain a third-party image scanning tool.\n\nThe scanning process is performed by comparing parent container images, dependencies, and libraries that are used by the container image to known CVEs. Dynamic container scanning is a process that scans the underlying infrastructure where containers run. It is executed post container deployment, and identifies vulnerabilities that may have been introduced by other software installed on the infrastructure itself. These vulnerabilities can be either modifications to an existing running container, or communication with a container that is exposed externally to other processes or hosts."
                            },
                            "improvementPlan": {
                                "displayText": "Ensure that your images are scanned for vulnerabilities"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SEC_04",
                    "title": "SEC 4. Infrastructure protection - How do you manage your container image boundaries?",
                    "description": "How do you detect and address vulnerabilities within your container image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Minimize attack surface",
                            "helpfulResource": {
                                "displayText": "In the context of container workloads, infrastructure protection is often a topic with respect to the container as a vector to access the underlying compute infrastructure. In any security context, reducing attack surface is top of mind. This can be accomplished when designing and building your container in a variety of ways:\n\n- Run distroless images without a shell or a package manager to ensure that bad actors cannot make changes to the image or easily download software packages to aid in their attack.\n- Build open-source libraries from source or scan libraries for vulnerabilities to ensure awareness of all of the components of the container image.\n- Remove or defang setuid and setgid bits from the container image to make sure that these permissions are not used in privilege escalation attacks.\n- Lint your Dockerfile to help identify violations of best practices for building container images.\n- Use a tool such as docker-slim to analyze existing images and remove unnecessary binaries not required by the application.\n- Ensure that your container is designed to operate with a read-only root filesystem. This functionality is normally defined at runtime but it is important to consider this facet when designing the container itself."
                            },
                            "improvementPlan": {
                                "displayText": "Minimize attack surface"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Understand the lineage of your container image",
                            "helpfulResource": {
                                "displayText": "Aside from reducing attack surface, it is also important to understand where your container images are coming from. If not building images from scratch, you should only run images from trusted registries that have been signed with a trusted signature to ensure integrity. Regarding signing images, it is recommended to utilize signed images to ensure that the contents of the container have not been modified before they are deployed. In general, don’t incorporate images directly from a public repository into your container pipeline. Private registries should be used to allow an organization to maintain complete control and visibility over their container image catalog. If using images originating from public repositories, they should be scanned, signed, and stored in a private registry to ensure that the contents of the image are known and verified against existing security standards."
                            },
                            "improvementPlan": {
                                "displayText": "Understand the lineage of your container image"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SEC_05",
                    "title": "SEC 5. Data protection - How do you handle data within your containerized applications?",
                    "description": "How do you handle data within your containerized applications?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Do not hardcode sensitive data into your container image",
                            "helpfulResource": {
                                "displayText": "With respect to handling data in the build and design of the container, it is important that no sensitive information is stored in the container itself. For example, user credentials should never be hardcoded into your container image. Instead, consider using a secret management protocol that is compatible with the container orchestration system being used to manage the container workloads."
                            },
                            "improvementPlan": {
                                "displayText": "Do not hardcode sensitive data into your container image"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Ensure that persistent data is stored outside of the container",
                            "helpfulResource": {
                                "displayText": "Also, if your containerized application writes or consumes persistent data, ensure that data is stored outside of the container. Since containers are intended to be ephemeral, use volumes to store persistent data that will remain intact long after a container’s lifecycle has completed."
                            },
                            "improvementPlan": {
                                "displayText": "Ensure that persistent data is stored outside of the container"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                }
            ]
        },
        {
            "id": "REL",
            "name": "Reliability",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_REL_01",
                    "title": "REL 1. Foundations - How do you limit the amount of CPU and memory a container consumes?",
                    "description": "How do you limit the amount of CPU and memory a container consumes?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use RAM and CPU limits",
                            "helpfulResource": {
                                "displayText": "By default, a running container will use the full RAM and CPU of the host system. This can lead to performance bottlenecks on the host and put your workload in a degraded state.\n\nSetting RAM and CPU limits on your running container will improve the availability of the host system and the workload. In Amazon ECS, update the CPU and memory parameters in the task definition to limit the CPU and RAM a container will consume."
                            },
                            "improvementPlan": {
                                "displayText": "Use RAM and CPU limits"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_REL_02",
                    "title": "REL 2. Workload architecture - How do you handle persistent data in a container application?",
                    "description": "How do you handle persistent data in a container application?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use volumes to persist data",
                            "helpfulResource": {
                                "displayText": "There are times when workloads have to store data across multiple containers. For example, an image-processing application that saves images for processing. Given the ephemeral nature of a container workload, data on the container will be lost once the container is restarted and longer exists.\n\nUse mounted volumes, whether block or network file system (NFS), to persist file data for an application. Mounted volumes allow for file data sharing among multiple running containers. In addition, mounted volumes should be used to persist logs or configuration files. For persisting data, use external database such as Amazon Relational Database Service (Amazon RDS), Amazon DynamoDB, or Amazon Aurora. Use a database system that provides performance, high-availability, and scalability to your container application when persisting data."
                            },
                            "improvementPlan": {
                                "displayText": "Use volumes to persist data"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_REL_03",
                    "title": "REL 3. Workload architecture - How do you automate building and testing of containers?",
                    "description": "How do you automate building and testing of containers?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Create local testing processes",
                            "helpfulResource": {
                                "displayText": "When building a containerized application, you want to be able to test your application as early as possible. That means that you have to think about how developers will be able to test their containerized application locally.\n\nFirst you will have to decide whether the container build for local testing will run on the developer’s machine or in a remote machine, because this will have an impact on the tooling that developers use on their machines.\n\nSecond, you will have to provide a local deployment mechanism. For this, you can use single containers that run as part of an automation script or deploy the containers locally using a local version of your target orchestrator. This can be also part of the testing section of your local build-script. With this approach, you can deploy necessary infrastructure components like databases in a lightweight fashion in order to test your application with the real infrastructure instead of mocked APIs.\n\nOne example might be a Docker Compose manifest to deploy multiple containers in a single command. For Kubernetes, use minikube to deploy the containerized application and all of its objects (such as Deployment, ConfigMaps, and Secrets)."
                            },
                            "improvementPlan": {
                                "displayText": "Create local testing processes"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Design your testing environments to support your container build pipeline",
                            "helpfulResource": {
                                "displayText": "When building a containerized application, you want to be able to test your application as early as possible. That means that you have to think about how developers will be able to test their containerized application locally.\n\nFirst you will have to decide whether the container build for local testing will run on the developer’s machine or in a remote machine, because this will have an impact on the tooling that developers use on their machines.\n\nSecond, you will have to provide a local deployment mechanism. For this, you can use single containers that run as part of an automation script or deploy the containers locally using a local version of your target orchestrator. This can be also part of the testing section of your local build-script.\n\nWith this approach, you can deploy necessary infrastructure components like databases in a lightweight fashion in order to test your application with the real infrastructure instead of mocked APIs. One example might be a Docker Compose manifest to deploy multiple containers in a single command. For Kubernetes, use minikube to deploy the containerized application and all of its objects (such as Deployment, ConfigMaps, and Secrets)."
                            },
                            "improvementPlan": {
                                "displayText": "Design your testing environments to support your container build pipeline"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "choice2",
                            "risk": "MEDIUM_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_REL_04",
                    "title": "REL 4. Change management - How do I cascade updates to a parent or base image?",
                    "description": "How do I cascade updates to a parent or base image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Create a standardized parent image",
                            "helpfulResource": {
                                "displayText": "Based on a lean parent image, a team- or enterprise-wide image can be created that provides optimizations to all teams. This could also be multiple parent images depending on the containerized application frameworks and languages. An organization could potentially start with a lean image containing company-specific configurations, and teams can add additional software that is necessary to run the different applications. This could be, for example, a Java Runtime Edition (JRE) or a specific Python version. One disadvantage of this solution is that if a parent image is changed, all images that use it - directly or indirectly - must also be recreated."
                            },
                            "improvementPlan": {
                                "displayText": "Create a standardized parent image"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Use an image hierarchy approach",
                            "helpfulResource": {
                                "displayText": "Try to maintain an image hierarchy in your container image strategy. A hierarchy or layered approach to container images helps with maintenance, cascading of updates to base images, and allows for the reuse of container images. In addition, it helps maintain the security posture of the broader organization by using the same images that have the security controls image managed by a central team. Operations like patching of a parent image should trigger a rebuild with changes to child images.\n\nAs a best practice, separate images into the following categories:\n- Intermediate base image\n- Application server\n- Application source code or binary\n\nThe intermediate base image is a small and lightweight base OS image."
                            },
                            "improvementPlan": {
                                "displayText": "Use an image hierarchy approach"
                            }
                        },
                        {
                            "id": "choice3",
                            "title": "Use source control and tagging on all container images",
                            "helpfulResource": {
                                "displayText": "Maintain the Dockerfile for all container images in a source control repository in the image hierarchy and ensure proper tagging of container images. In addition, use a contentious integration process to create a direct correlation between the container's images in source control and the image tag. This best practice is critical to determine what changed in the container image from a prior release.\n\nFor example, tag 1.0 indicates that this tag will always point to the latest patch release 1.0.1, 1.0.2, 1.0.3, and so on."
                            },
                            "improvementPlan": {
                                "displayText": "Use source control and tagging on all container images"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2 && choice3",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_REL_05",
                    "title": "REL 5. Failure management - How do you monitor the health of a container?",
                    "description": "How do you monitor the health of a container?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Plan for health checks in all containers builds and deployments",
                            "helpfulResource": {
                                "displayText": "It is common to initially develop container applications without thinking of the availability of the services in the container. When running container applications, there is no way of knowing whether the services running within a container are up or not. Adding a health check or probe to the container provides testing of the services in the container. Health check options are available in Docker using the HEALTHCHECK command, however, containerd does not have this option. Examine the orchestrations systems health check and probing options. This could include liveness and readiness probes within Amazon EKS or health checks within a definition file within Amazon ECS."
                            },
                            "improvementPlan": {
                                "displayText": "Plan for health checks in all containers builds and deployments"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                }
            ]
        },
        {
            "id": "PERF",
            "name": "Performance efficiency",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_PERF_01",
                    "title": "PERF 1. Selection - How do you reduce the size of your container image?",
                    "description": "How do you reduce the size of your container image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use small parent images",
                            "helpfulResource": {
                                "displayText": "The OS parent image that is used to create the target images has a huge impact on the final container image size.\n\nWe can use Alpine to build performant containers, but for certain languages there are even more optimized run environments we can leverage. When using statically linked binaries, scratch can be an alternative."
                            },
                            "improvementPlan": {
                                "displayText": "Use small parent images"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Run a single process per container",
                            "helpfulResource": {
                                "displayText": "It is highly recommended to limit the number of processes in each container to one. This approach simplifies the implementation of separations of concerns using simple services. Each container should only be responsible for a single aspect of the application that facilitates horizontal scaling of this particular aspect. If it’s necessary to run more than one process per container, use a proper process supervisor (like supervisord) and an init system (like tini)."
                            },
                            "improvementPlan": {
                                "displayText": "Run a single process per container"
                            }
                        },
                        {
                            "id": "choice3",
                            "title": "Exclude files with from your build process",
                            "helpfulResource": {
                                "displayText": "The .dockerignore file is similar to .gitignore and is used to exclude files that are not necessary for the build, or are of a sensitive nature. This can be useful if it’s not possible to restructure the source code directory to limit the build context. The following example shows a typical .dockerignore file, which excludes files like the compilation target-directory, JAR-files, and subdirectories."
                            },
                            "improvementPlan": {
                                "displayText": "Exclude files with from your build process"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "choice1 && choice2 && !choice3 || choice1 && !choice2 && choice3 || !choice1 && choice2 && choice3",
                            "risk": "MEDIUM_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_PERF_02",
                    "title": "PERF 2. Selection - How do you reduce the pull time of your container image?",
                    "description": "How do you reduce the pull time of your container image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use a container registry close to your cluster",
                            "helpfulResource": {
                                "displayText": "One of the essential factors in the speed of deploying container images from a registry is locality. The registry should be as close to the cluster as possible, which means that both the cluster and the registry should be in the same AWS Region. For multi-region deployments, this means that the CI/CD chain should publish a container image to multiple Regions. An additional way to optimize the pull time of your container image is to keep the container image as small as possible. In Tradeoffs multi-stage builds are discussed in detail to reduce the image size."
                            },
                            "improvementPlan": {
                                "displayText": "Use a container registry close to your cluster"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_PERF_03",
                    "title": "PERF 3. Review - How do you make sure to get consistent results for your target images?",
                    "description": "How do you make sure to get consistent results for your target images?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Don't use the latest tag for your parent image",
                            "helpfulResource": {
                                "displayText": "Using the latest tag for the parent image could potentially lead to issues because the latest version of the image might include breaking changes compared to the version that is currently used."
                            },
                            "improvementPlan": {
                                "displayText": "Don't use the latest tag for your parent image"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_PERF_04",
                    "title": "PERF 4. Review - How do you make sure to use updated versions for parent images?",
                    "description": "How do you make sure to use updated versions for parent images?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Implement a notification mechanism for updated parent images",
                            "helpfulResource": {
                                "displayText": "If you’re using a team- or enterprise-wide image, you should implement a notification mechanism based as part of your CI/CD chain to distribute the information about a new parent image to the teams. The teams should build target images with the new parent images and measure the performance impact of the changes by running a proper test suite."
                            },
                            "improvementPlan": {
                                "displayText": "Implement a notification mechanism for updated parent images"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_PERF_05",
                    "title": "PERF 5. Monitoring - How do you make sure you get consistent performance results over time?",
                    "description": "How do you make sure you get consistent performance results over time?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Implement an automated performance testing strategy",
                            "helpfulResource": {
                                "displayText": "System performance can degrade over time. It’s important to have an automated testing and monitoring system in place to identify degradation of performance. Every time you build target images based on new parent images, you should measure the performance impact of the changes in the parent image. This also includes the overall build process, because we have to make sure that a testing and monitoring system covers the CI/CD chain. Performance metrics and image sizes have to be collected using services like Amazon CloudWatch and teams must be alarmed if anomalies have been detected."
                            },
                            "improvementPlan": {
                                "displayText": "Implement an automated performance testing strategy"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_PERF_06",
                    "title": "PERF 6. Tradeoffs - How do you optimize the size of your target image?",
                    "description": "How do you optimize the size of your target image?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use caching during build",
                            "helpfulResource": {
                                "displayText": "A container image is created using layers. Each statement in a Dockerfile (like RUN or COPY) creates a new layer. These layers are stored in a local image cache and can be reused in the next build. The cache can be invalidated by changing the Dockerfile, which means that all subsequent steps to build the image must be rerun. Naturally, this has a great influence on the speed the image is built. Thus, the order of the commands in your Dockerfile can have a dramatic effect on build performance."
                            },
                            "improvementPlan": {
                                "displayText": "Use caching during build"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Use the CPU architecture with best price to performance ratio",
                            "helpfulResource": {
                                "displayText": "AWS Graviton-based Amazon EC2 instances deliver up to 40% better price performance over comparable current generation x86-based instances for a broad spectrum of workloads. Instead of using one build-server for x86 and ARM in combination with QEMU for CPU emulation, it might be a more efficient architecture to use at least one build server per CPU architecture."
                            },
                            "improvementPlan": {
                                "displayText": "Use the CPU architecture with best price to performance ratio"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                }
            ]
        },
        {
            "id": "COST",
            "name": "Cost optimization",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_COST_01",
                    "title": "COST 1. Practice cloud financial management - How do you design your container build process to avoid unnecessary cost?",
                    "description": "How do you design your container build process to avoid unnecessary cost?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Don't keep unnecessary container images",
                            "helpfulResource": {
                                "displayText": "Building a containerized application can result in multiple images for the same service. Depending on your organization policy, you might want to keep a subset of your container images to be used in a case of a rollback scenario. An example of such a policy might be that you don’t roll back more than three versions, or more than three months in time. That means, that not all container images of a specific application should be kept. Deleting old images can save costs as container registries charge by size of images stored in the registry. You can achieve this deletion policy by creating automation processes, or use service features."
                            },
                            "improvementPlan": {
                                "displayText": "Don't keep unnecessary container images"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_02",
                    "title": "COST 2. Expenditure and usage awareness - How do you design your container build process to avoid unnecessary cost?",
                    "description": "How do you design your container build process to avoid unnecessary cost?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Designing efficient container build process",
                            "helpfulResource": {
                                "displayText": "Building containers is a process that consumes compute and storage resources and can lead to unnecessary costs if not using it properly. The build process consumes resources for each build, and there are some considerations that have to be taken for it to be efficient from a cost perspective."
                            },
                            "improvementPlan": {
                                "displayText": "Design an efficient container build process"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Application dependencies",
                            "helpfulResource": {
                                "displayText": "The container image is usually being built alongside with the application build step. During this build step, all necessary dependencies, libraries, and modules that are being used by the application code are downloaded to the container image. Using unnecessary dependencies will make the build time longer, and will result in wasting compute resources of the build system."
                            },
                            "improvementPlan": {
                                "displayText": "Don't use unnecessary application dependencies"
                            }
                        },
                        {
                            "id": "choice3",
                            "title": "Common container image dependencies",
                            "helpfulResource": {
                                "displayText": "Some operating system packages are needed for multiple applications in the organization for a specific runtime (for example, Python and Java). Building a parent container image that preinstalls all common operating system packages and dependencies for the specific runtime will result in a more efficient build process. Without this common image, each individual container image would be installing the same packages, thus wasting compute and network resources. This practice will also shorten the time for container images built from a specific runtime, since all of its common operating system packages and dependencies are already included in the parent container image. As a result, this will reduce costs for building all other container images that use this parent image."
                            },
                            "improvementPlan": {
                                "displayText": "Preinstall common container image dependencies in parent image"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2 && choice3",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_03",
                    "title": "COST 3. Cost-effective resources - Ensure that your container images contain only what is relevant for your application to run",
                    "description": "Ensure that your container images contain only what is relevant for your application to run",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Containerized application start-up time",
                            "helpfulResource": {
                                "displayText": "Container image size affects the time needed for an image to be pulled from a container registry. Large image sizes (hundreds, or thousands of MB), can lead to a slow startup time of the application, which can lead to:\n- Waste compute resources while waiting for images to be pulled.\n- Slow scale-out operations.\nContainer image size also affects the scaling time needed for a containerized application to become ready to receive traffic. This time can translate to a waste of resources. In small-scale replicas of your application, the waste might not be notable, but when dealing with a dynamic autoscaled environment, a 30-second delay between a triggered scale-out event and a container ready to run can result in hundreds of compute minutes wasted per month."
                            },
                            "improvementPlan": {
                                "displayText": "Keep your container size as small as possible for a faster start-up time"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Storage requirements for containers",
                            "helpfulResource": {
                                "displayText": "Consider your instance’s storage requirements depending on your container image size. The size of your container image has a direct effect on the instance storage size that the container will run on. This can result in the need for a larger storage size for your instances.\n\nContainer image size also affects the storage requirements of the container registry, since the container image will be stored in the registry. Stored images in Amazon ECR are priced per GB-month. For current pricing, refer to the pricing page."
                            },
                            "improvementPlan": {
                                "displayText": "Keep your container size as small as possible for smaller storage requirements"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_04",
                    "title": "COST 4. Cost-effective resources - How do you reduce your container images size?",
                    "description": "How do you reduce your container images size?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Reduce the count of layers in your container image",
                            "helpfulResource": {
                                "displayText": "A container image consists of read-only layers that represent a Dockerfile instruction. Each instruction creates one additional layer on top of the previous layer. Running multiple consecutive commands can result in a large container image size, even if we delete content in the container image itself.\n\nReducing image layers can be done with several techniques:\n- Building container images from the scratch image\n- Use lightweight base images\n- Reducing the number of RUN instructions by chaining commands together\n- Consider using package managers flags to reduce dependency sizes\n- Use multi-stage builds\n- Follow Dockerfile best practices."
                            },
                            "improvementPlan": {
                                "displayText": "Reduce the count of layers in your container image"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_05",
                    "title": "COST 5. Cost-Eff Res - How do you design your containerized application to support automatic scaling and graceful termination?",
                    "description": "How do you design your containerized application to support automatic scaling and graceful termination?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Handle system signals and react according to the application logic",
                            "helpfulResource": {
                                "displayText": "When designing applications that will be containerized, it is important to include signal handling within the code and/or the container itself. Handling signals is a fundamental practice for writing applications, especially when writing applications that will run inside a container. The application should handle system signals and react according to the application logic. Although this is not directly related to cost, handling signals is a key element for using cost saving practices like automatic scaling or using Amazon EC2 Spot Instances. When a scale-in event, or replacement or termination of a Spot Instance occurs, the container orchestrator system or tools will send a SIGTERM signal to the application notifying the application to shut itself down gracefully. If it fails to do so, the process may end up being terminated while performing work, which can prohibit the use of auto scaling or spot in general."
                            },
                            "improvementPlan": {
                                "displayText": "Handle system signals and react according to the application logic"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "HIGH_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_06",
                    "title": "COST 6. Cost-effective resources - How do you design your containerized application to support multiple CPU architectures?",
                    "description": "How do you design your containerized application to support multiple CPU architectures?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Support multiple CPU architectures",
                            "helpfulResource": {
                                "displayText": "Different instance families offer different performance for the same amount of hardware (CPU and memory). An example is using a newer instead of an older generation of instances, or using instances with different CPU architecture, such as ARM. To use a different instance architecture, you have to change your build process. Since the default behavior of the build process is to create a container image that is designed to run on the architecture of the instance that it was built on, you have to create multiple images for each CPU architecture. To create multiple images, run the same build process on an x86 instance, and on an ARM-based instance. Use tagging suffixes to differentiate between the different architectures."
                            },
                            "improvementPlan": {
                                "displayText": "Support multiple CPU architectures"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_07",
                    "title": "COST 7. Manage demand and supply resources - How do you minimize cost for your containerized application during startup time?",
                    "description": "How do you minimize cost for your containerized application during startup time?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Shorten startup times for containerized applications",
                            "helpfulResource": {
                                "displayText": "Longer startup times for containerized applications can result in wasted compute resources. Shortening startup times can be done on the application-level (code optimization), or on the container level. For example, if the application needs external dependencies to be present in the container, it should be already installed during the build process, or it should be included in the parent image, and not downloaded at startup using an entrypoint script or DOCKERFILE commands."
                            },
                            "improvementPlan": {
                                "displayText": "Shorten startup times for containerized applications"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_COST_08",
                    "title": "COST 8. Manage demand and supply resources - What systems are you using to create your container build process?",
                    "description": "What systems are you using to create your container build process?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use a build and pipeline service",
                            "helpfulResource": {
                                "displayText": "Creating any build process requires developing, maintaining, and operating a build system. This can be done by a variety of methods, such as using OSS tooling for job automation, or using self-developed systems that are able to run build scripts for your application. However, running and maintaining this kind of system involves software development costs, operational costs, compute, and storage costs for running the system. Alternatively you can use build and pipeline services, such as Amazon EC2 Image Builder, AWS CodeBuild, and AWS CodePipeline. Using managed services removes the operational overhead and allows developers to consume pipeline runs and build jobs on a pay-as-you-go basis."
                            },
                            "improvementPlan": {
                                "displayText": "Use a build and pipeline service"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                }
            ]
        },
        {
            "id": "SUSTAINABILITY",
            "name": "Sustainability",
            "questions": [
                {
                    "id": "CONTAINER_BUILD_SUSTAINABILITY_01",
                    "title": "SUS 1. SW&A patterns - How do you design your containerized application in a way that reduces the use of underlying resources?",
                    "description": "Software and architecture - How do you design your container build process to avoid unnecessary cost?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Remove unnecessary dependencies",
                            "helpfulResource": {
                                "displayText": "When designing containerized application, you should keep your build manifests up-to-date and aligned with your application needs. A containerized application image starts from a Dockerfile. The Dockerfile includes all commands required to include the configuration and dependencies for the containerized application. If there are some dependencies that are no longer required, removing them from the Dockerfile can:\n- Reduce the time that it takes to build the container image. This affects host resource consumption by the build process.\n- Reduce the container image size and therefore reduce the time it takes for this image to be pulled to an instance. This affects host resources usage for running and storing the container images."
                            },
                            "improvementPlan": {
                                "displayText": "Remove unnecessary dependencies"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SUSTAINABILITY_02",
                    "title": "SUS 2. Hardware patterns - How do you support your containerized application to run on energy-efficient hardware?",
                    "description": "How do you support your containerized application to run on energy-efficient hardware?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use instance types with the least environmental impact",
                            "helpfulResource": {
                                "displayText": "To be able to use instance types with the least environmental impact (from the Sustainability Pillar whitepaper), you have to ensure your containerized application is able to run on a variety of instance types and architectures. This can be done by creating images that support multi-architecture as described in the Cost Optimization Pillar whitepaper . For example, you can use a build service that supports multi-architecture build servers and combine them to a multi-architecture image using the CI pipeline (see Graviton workshop as an example of using AWS CodeBuild, and AWS CodePipeline alongside Graviton and Amazon EKS). You can also use tools that generate multi-architecture images from a single Dockerfile, such as Docker Buildx."
                            },
                            "improvementPlan": {
                                "displayText": "Use instance types with the least environmental impact"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                },
                {
                    "id": "CONTAINER_BUILD_SUSTAINABILITY_03",
                    "title": "SUS 3. Dev&deploy process - How do you design your build tooling and services to improve efficiency of the underlying resources?",
                    "description": "How do you design your build tooling and services to improve efficiency of the underlying resources?",
                    "choices": [
                        {
                            "id": "choice1",
                            "title": "Use dynamically created build servers for building your containerized workload",
                            "helpfulResource": {
                                "displayText": "Using dynamically created build servers (such as AWS CodeBuild), ensures that while building your containerized images, the needed infrastructure is being provisioned when the build process starts, and being terminated as soon as the build process ends."
                            },
                            "improvementPlan": {
                                "displayText": "Use dynamically created build servers for building your containerized workload"
                            }
                        },
                        {
                            "id": "choice2",
                            "title": "Use pre-defined or built runtimes to reduce your build time, and reuse needed dependencies for the build process",
                            "helpfulResource": {
                                "displayText": "When building different types of containerized applications, using common and standardized runtimes for the build process reduces the operational management of creating and maintaining custom images. Also, by using the specific type of runtime for your build server, it verifies that no common dependency is being downloaded and configured as part of the build process. All relevant dependencies are being incorporated into the different runtimes of your build servers, and are being used many times by different build processes for different applications. An example of multiple build runtimes can be found in the AWS CodeBuild documentation."
                            },
                            "improvementPlan": {
                                "displayText": "Use pre-defined or built runtimes to reduce your build time, and reuse needed dependencies for the build process"
                            }
                        },
                        {
                            "id": "choice3",
                            "title": "Update your parent and base image regularly",
                            "helpfulResource": {
                                "displayText": "Update your base and parent images to the latest versions, as sometimes there is a performance improvement that is introduced in newer versions. These improvements are translated into a sustainability improvement as it affects the resource consumption of the underlying infrastructure, and as a result improves the overall efficiency."
                            },
                            "improvementPlan": {
                                "displayText": "Update your parent and base image regularly"
                            }
                        },
                        {
                            "id": "choice4",
                            "title": "Delete unused or obsolete container images",
                            "helpfulResource": {
                                "displayText": "As described in the Cost Optimization Pillar whitepaper, create mechanisms to verify that unused or obsolete container images are deleted. This can be achieved, for example, by registry lifecycle policies, as exists in Amazon ECR."
                            },
                            "improvementPlan": {
                                "displayText": "Delete unused or obsolete container images"
                            }
                        },
                        {
                            "id": "choice_no",
                            "title": "None of these",
                            "helpfulResource": {
                                "displayText": "Choose this if your workload does not follow these best practices."
                            }
                        }
                    ],
                    "riskRules": [
                        {
                            "condition": "choice1 && choice2 && choice3 && choice4",
                            "risk": "NO_RISK"
                        },
                        {
                            "condition": "default",
                            "risk": "MEDIUM_RISK"
                        }
                    ]
                }
            ]
        }
    ]
}